var api = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get consent () { return consent; },
    get data () { return data; },
    get getData () { return getData; },
    get getUserId () { return getUserId; },
    get init () { return init; },
    get keys () { return keys; },
    get tag () { return tag; },
    get user () { return user; }
});

const getUserAgent = () => {
    try {
        const nav = navigator;
        return nav.userAgent;
    }
    catch {
        return '';
    }
};
const getReferrer = () => {
    let referrer = '';
    try {
        const referrerUrl = new URL(document.referrer);
        if (referrerUrl.host !== window.location.host) {
            referrer = referrerUrl.href;
        }
        return referrer;
    }
    catch (error) {
        return referrer;
    }
};
const getPageUrl = () => {
    try {
        if (window.edgetagData && window.edgetagData['pageUrl']) {
            return window.edgetagData['pageUrl'];
        }
        return window.location.href;
    }
    catch {
        return '';
    }
};
const getSearch = () => {
    try {
        return window.location.search;
    }
    catch {
        return '';
    }
};
const getLocale = () => {
    try {
        return navigator.language;
    }
    catch {
        return '';
    }
};
const getPageTitle = () => {
    try {
        return document.title;
    }
    catch {
        return '';
    }
};

const tagStorage = 'edgeTag';
const consentKey = 'consent';
const keyPrefix = `_worker`;
const cookieKey = 'tag_user_id';

const getMessage = (error) => {
    if (error instanceof Error) {
        return error.message;
    }
    if (typeof error === 'string') {
        return error;
    }
    try {
        return JSON.stringify(error);
    }
    catch {
        return error;
    }
};
const allowLog = () => {
    try {
        return localStorage.getItem('edgeTagDebug') === '1';
    }
    catch {
        return false;
    }
};
const log = (data) => {
    if (!allowLog()) {
        return;
    }
    console.log('[EdgeTag]', getMessage(data));
};
const error = (data) => {
    console.error('[EdgeTag]', getMessage(data));
};

const initKey = `${keyPrefix}Store`;
const saveDataPerKey = (persistType, provider, value, key) => {
    const storage = getData$1(persistType);
    if (!storage['data']) {
        storage['data'] = {};
    }
    if (!storage['data'][provider]) {
        storage['data'][provider] = {};
    }
    storage['data'][provider][key] = value;
    saveData(persistType, storage);
};
const savePerKey = (persistType, provider, value, key) => {
    const storage = getData$1(persistType);
    if (!storage[provider]) {
        storage[provider] = {};
    }
    storage[provider][key] = value;
    saveData(persistType, storage);
};
const getDataPerKey = (persistType, provider, key) => {
    const storage = getData$1(persistType);
    if (!storage[provider]) {
        return undefined;
    }
    return storage[provider][key];
};
const saveData = (persistType, value, key = initKey) => {
    if (persistType === 'session') {
        saveSession(value, key);
        return;
    }
    saveLocal(value, key);
};
const getData$1 = (persistType, key = initKey) => {
    if (persistType === 'session') {
        return getSession(key);
    }
    return getLocal(key);
};
const saveKV = (data) => {
    let currentSession = getData$1('session');
    if (!currentSession) {
        currentSession = {};
    }
    if (!currentSession['kv']) {
        currentSession['kv'] = {};
    }
    currentSession['kv'] = {
        ...currentSession['kv'],
        ...data,
    };
    saveData('session', currentSession);
};
const saveLocal = (value, key) => {
    try {
        if (!localStorage) {
            return;
        }
        localStorage.setItem(key, JSON.stringify(value));
    }
    catch {
        log('Local storage not supported.');
    }
};
const getLocal = (key) => {
    try {
        if (!localStorage) {
            return {};
        }
        const data = localStorage.getItem(key);
        if (!data) {
            return {};
        }
        return JSON.parse(data) || {};
    }
    catch {
        return {};
    }
};
const saveSession = (value, key) => {
    try {
        if (!sessionStorage) {
            return;
        }
        sessionStorage.setItem(key, JSON.stringify(value));
    }
    catch {
        log('Session storage not supported.');
    }
};
const getSession = (key) => {
    try {
        if (!sessionStorage) {
            return {};
        }
        const data = sessionStorage.getItem(key);
        if (!data) {
            return {};
        }
        return JSON.parse(data) || {};
    }
    catch {
        return {};
    }
};

const encodeString = (name) => {
    if (typeof btoa === 'undefined') {
        return Buffer.from(name).toString('base64');
    }
    return btoa(name);
};
const getBasicRandomNumber = () => {
    return parseInt((Math.random() * 10000000000).toString(), 10);
};
const generateUUID = () => {
    let id = '';
    try {
        id = crypto.randomUUID();
        if (!id) {
            const array = new Uint32Array(20);
            const numbers = crypto.getRandomValues(array);
            for (let i = 0; i < 5; i++) {
                const y = i * 3;
                if (i !== 0) {
                    id += '-';
                }
                const sum = numbers[y + 1] + numbers[y + 2] + numbers[y + 3];
                id += sum.toString();
            }
        }
    }
    catch {
        id = `${getBasicRandomNumber()}-${getBasicRandomNumber()}-${getBasicRandomNumber()}-${getBasicRandomNumber()}-${getBasicRandomNumber()}`;
        console.log('[EdgeTag] Crypto module not found');
    }
    return id;
};
const generateEventId = (name) => {
    let time = Date.now().toString();
    if (typeof performance !== 'undefined' &&
        typeof performance.now === 'function') {
        const perf = performance.now();
        if (perf) {
            time = perf.toFixed(4);
        }
    }
    return `${encodeString(name)}-${generateUUID()}-${time}`;
};

const getCookieValue = (key) => {
    try {
        if (!document || !document.cookie) {
            return '';
        }
        const name = `${key}=`;
        const decodedCookie = decodeURIComponent(document.cookie);
        const ca = decodedCookie.split(';');
        for (let i = 0; i < ca.length; i++) {
            let c = ca[i];
            while (c.charAt(0) === ' ') {
                c = c.substring(1);
            }
            if (c.indexOf(name) === 0) {
                return c.substring(name.length, c.length);
            }
        }
        return '';
    }
    catch {
        return '';
    }
};

let initUserId = '';
const handleGetUserId = () => {
    if (initUserId) {
        return initUserId;
    }
    // leaving this for backward compatibility as worker was maybe not updated yet
    // reference https://github.com/blotoutio/solutions/issues/1960
    return getCookieValue(cookieKey);
};
const setUserId = (userId) => {
    initUserId = userId;
};

const beacon = (url, payload) => {
    try {
        let blob;
        if (payload) {
            blob = new Blob([JSON.stringify(payload)], { type: 'application/json' });
        }
        return navigator.sendBeacon(url, blob);
    }
    catch (e) {
        return Promise.reject(new Error('Beacon not supported.'));
    }
};
const ajax = (method, url, payload) => fetch(url, {
    method,
    headers: {
        'Content-type': 'application/json; charset=utf-8',
        Accept: 'application/json; charset=utf-8',
        EdgeTagUserId: handleGetUserId(),
    },
    body: JSON.stringify(payload),
    credentials: 'include',
})
    .then((response) => response
    .json()
    .then((data) => ({ status: response.status, body: data })))
    .then(({ status, body }) => {
    if (status < 200 || status >= 300) {
        throw new Error(`Request failed with code ${status}: ${JSON.stringify(body)}`);
    }
    return Promise.resolve(body);
});
const getStandardPayload = (payload) => {
    const data = {
        pageUrl: getPageUrl(),
        pageTitle: getPageTitle(),
        userAgent: getUserAgent(),
        referrer: getReferrer(),
        search: getSearch(),
        locale: getLocale(),
        sdkVersion: "0.34.0" ,
        ...(payload || {}),
    };
    let storage = {};
    const session = getData$1('session');
    if (session) {
        storage = {
            ...storage,
            ...session,
        };
    }
    const local = getData$1('local');
    if (local) {
        storage = {
            ...storage,
            ...local,
        };
    }
    data.storage = storage;
    return data;
};
async function postRequest(url, data, options) {
    if (!url) {
        return Promise.reject(new Error('URL is empty.'));
    }
    const payload = getStandardPayload(data);
    if (options && options.method === 'beacon') {
        return Promise.resolve(beacon(url, payload));
    }
    return await ajax('POST', url, payload);
}
async function getRequest(url, options) {
    if (!url) {
        return Promise.reject(new Error('URL is empty.'));
    }
    if (options && options.method === 'beacon') {
        return {
            result: Promise.resolve(beacon(url)),
        };
    }
    return await ajax('GET', url);
}

let endpointUrl = '';
const generateUrl = (path) => {
    const endpoint = getUrl();
    if (!endpoint) {
        log('URL is not valid');
        return '';
    }
    return `${endpoint}${path}`;
};
const getUrl = () => {
    return endpointUrl;
};
const setUrl = (url) => {
    if (url == null) {
        return;
    }
    endpointUrl = url;
};
const getTagURL = (options) => {
    const url = new URL(generateUrl('/tag'));
    if (options === null || options === void 0 ? void 0 : options.sync) {
        url.searchParams.set('sync', 'true');
    }
    return url.toString();
};
const getInitURL = () => {
    return generateUrl('/init');
};
const getConsentURL = () => {
    return generateUrl('/consent');
};
const getUserURL = () => {
    return generateUrl('/user');
};
const getDataURL = () => {
    return generateUrl(`/data`);
};
const getGetDataURL = (keys) => {
    return generateUrl(`/data?keys=${encodeURIComponent(keys.join(','))}`);
};
const getKeysURL = () => {
    return generateUrl(`/keys`);
};

let memoryConsent;
const saveConsent = (consent) => {
    setConsent(consent);
    savePerKey('local', tagStorage, consent, consentKey);
};
const handleConsent = (consent, options) => {
    const payload = {
        consentString: consent,
    };
    saveConsent(consent);
    if (!(options === null || options === void 0 ? void 0 : options.localSave)) {
        postRequest(getConsentURL(), payload).catch(error);
    }
};
const setConsent = (newConsent) => {
    memoryConsent = newConsent;
};
const getConsent = () => {
    const storageConsent = getDataPerKey('local', tagStorage, consentKey);
    if (storageConsent) {
        return storageConsent;
    }
    return memoryConsent;
};

const isBool = (v) => typeof v == 'boolean';
const isRecord = (v) => !!v && typeof v == 'object' && !Array.isArray(v);
/**
 * This function validates user consent for a given provider and tag name.
 * It should be used in conjunction with `UserConsent`, not `ProvidersConfig`.
 */
const hasUserConsent = (consent, provider, tagName) => {
    if (!isRecord(consent)) {
        return false;
    }
    let allowed = isBool(consent.all) ? consent.all : false;
    if (provider in consent) {
        const providerSpecific = consent[provider];
        if (isBool(providerSpecific)) {
            allowed = providerSpecific;
        }
        else if (isRecord(providerSpecific)) {
            if ('all' in providerSpecific && isBool(providerSpecific.all)) {
                allowed = providerSpecific.all;
            }
            if (tagName in providerSpecific && isBool(providerSpecific[tagName])) {
                allowed = providerSpecific[tagName];
            }
        }
    }
    return allowed;
};
/**
 * This function validates provider allowance for a given provider and tag name.
 * It should not be used to validate `UserConsent`.
 */
const isProviderInstanceAllowed = (providersConfig, provider, tagName) => {
    if (!isRecord(providersConfig)) {
        return true;
    }
    if (provider in providersConfig) {
        const providerSpecific = providersConfig[provider];
        if (isBool(providerSpecific)) {
            return providerSpecific;
        }
        if (isRecord(providerSpecific)) {
            const tagKeys = Object.keys(providerSpecific).filter((k) => k != 'all');
            if (tagName in providerSpecific && isBool(providerSpecific[tagName])) {
                return providerSpecific[tagName];
            }
            return isBool(providerSpecific.all)
                ? providerSpecific.all
                : tagKeys.length == 0;
        }
    }
    const providerKeys = Object.keys(providersConfig).filter((k) => k != 'all');
    return isBool(providersConfig.all)
        ? providersConfig.all
        : providerKeys.length == 0;
};

const upsert = (map, key, update, createDefault) => {
    const currentValue = map.has(key)
        ? map.get(key)
        : createDefault();
    return map.set(key, update(currentValue));
};

let initialized = false;
const providersPackages = {};
const setPreferences = (preferences) => {
    var _a;
    if (!preferences) {
        return false;
    }
    if (!preferences.edgeURL) {
        error('Please provide URL for EdgeTag');
        return false;
    }
    !!preferences.disableConsentCheck;
    (_a = preferences.providers) === null || _a === void 0 ? void 0 : _a.forEach((provider) => {
        if (!provider.name) {
            return;
        }
        providersPackages[provider.name] = provider;
    });
    try {
        if (window && Array.isArray(window.edgetagProviders)) {
            window.edgetagProviders.forEach((provider) => {
                if (!provider.name) {
                    return;
                }
                providersPackages[provider.name] = provider;
            });
        }
    }
    catch {
        // do nothing
    }
    setUrl(preferences.edgeURL);
    return true;
};
const getProvidersPackage = () => providersPackages;
const isInitialized = () => initialized;
const setInitialized = () => {
    initialized = true;
};
const configuredTags = new Map();
const addConfiguredTag = (pkg, tagName) => upsert(configuredTags, pkg, (names) => names.add(tagName), () => new Set());
const getConfiguredTags = () => configuredTags;

const manifestVariables = {};
const addProviderVariable = (name, variables, tagName) => {
    manifestVariables[name] = {
        ...manifestVariables[name],
        [tagName]: variables || {},
    };
};
const getProviderVariables = (name) => {
    if (!name) {
        return {};
    }
    return manifestVariables[name] || {};
};

let stubs = [];
const addStubs = (newStubs) => {
    stubs = [...stubs, ...newStubs];
};
const addStub = (stub) => {
    stubs.push(stub);
};
const processStubs = () => {
    try {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        stubs.forEach((stub) => api[stub.name](...(stub.arguments || [])));
        stubs = [];
    }
    catch (e) {
        error(e);
    }
};

const sendTag = ({ eventName, eventId, data, providerData, providers, options, }) => {
    const payload = {
        eventName,
        eventId,
        timestamp: Date.now(),
        data,
        providerData,
    };
    if (providers) {
        payload.providers = providers;
    }
    postRequest(getTagURL(options), payload, options).catch(error);
};
const handleTag = (eventName, data = {}, providers, options) => {
    if (!isInitialized()) {
        addStub({
            name: 'tag',
            arguments: [eventName, data, providers, options],
        });
        return;
    }
    let eventId = data['eventId'];
    if (!eventId) {
        eventId = generateEventId(eventName);
    }
    const providerPackages = getProvidersPackage();
    const configuredTags = getConfiguredTags();
    const userId = handleGetUserId();
    const providerData = {};
    const consent = getConsent();
    for (const pkg of Object.values(providerPackages)) {
        if (!pkg || !pkg.name || !pkg.tag) {
            continue;
        }
        if (!configuredTags.has(pkg.name)) {
            log(`Provider ${pkg.name} is not in allow list`);
            continue;
        }
        const variables = getProviderVariables(pkg.name);
        const result = {};
        const providerVariables = Object.entries(variables);
        const executionContext = new Map();
        for (const [tagName, variableSet] of providerVariables) {
            if (!isProviderInstanceAllowed(providers, pkg.name, tagName)) {
                log(`Provider instance is not allowed (${pkg.name}: ${tagName})`);
                continue;
            }
            if (!hasUserConsent(consent, pkg.name, tagName)) {
                log(`Consent is missing (${pkg.name}: ${tagName})`);
                continue;
            }
            result[tagName] = pkg.tag({
                userId,
                eventName,
                eventId,
                data: JSON.parse(JSON.stringify(data)),
                sendTag,
                manifestVariables: variableSet,
                executionContext,
            });
        }
        providerData[pkg.name] = result;
    }
    if (!hasAllowedManifestTags(configuredTags, consent, providers)) {
        return;
    }
    sendTag({
        eventName,
        eventId,
        data,
        providerData,
        providers,
        options,
    });
};
const hasAllowedManifestTags = (tags, consent, providersConfig) => {
    for (const [pkg, tagNames] of tags) {
        for (const tagName of tagNames) {
            if (hasUserConsent(consent, pkg, tagName) &&
                isProviderInstanceAllowed(providersConfig, pkg, tagName)) {
                return true;
            }
        }
    }
    return false;
};

const handleData = (data, providers, options) => {
    if (!data || Object.keys(data).length === 0) {
        error('Provide data for data API.');
        return;
    }
    saveKV(data);
    const providerPackages = getProvidersPackage();
    const configuredTags = getConfiguredTags();
    const userId = handleGetUserId();
    const consent = getConsent();
    for (const pkg of Object.values(providerPackages)) {
        if (!pkg || !pkg.user || !pkg.name) {
            continue;
        }
        if (!configuredTags.has(pkg.name)) {
            log(`Provider ${pkg.name} is not in allow list`);
            continue;
        }
        const variables = getProviderVariables(pkg.name);
        for (const [tagName, variableSet] of Object.entries(variables)) {
            if (!isProviderInstanceAllowed(providers, pkg.name, tagName)) {
                log(`Data not allowed for ${pkg.name} (${tagName})`);
                continue;
            }
            if (!hasUserConsent(consent, pkg.name, tagName)) {
                log(`Consent is missing for ${pkg.name} (${tagName})`);
                continue;
            }
            pkg.user({
                userId,
                data,
                manifestVariables: variableSet,
            });
        }
    }
    postRequest(getDataURL(), { data, providers }, options).catch(error);
};

const cacheKey = `${keyPrefix}Cache`;
const saveDataToEdge = (key, value, provider) => {
    if (!value) {
        return;
    }
    if (typeof value !== 'string') {
        try {
            value = JSON.stringify(value);
        }
        catch {
            log('Error stringify value.');
            return;
        }
    }
    handleData({ [`${provider}::${key}`]: value });
};
const handleCaptureQuery = (provider, key, persistType) => {
    try {
        if (!window) {
            return;
        }
    }
    catch {
        return;
    }
    const params = new URLSearchParams(window.location.search);
    if (!params || !params.get(key)) {
        return;
    }
    const data = params.get(key);
    if (!data) {
        return;
    }
    if (persistType === 'edge') {
        saveDataToEdge(key, data, provider);
        return;
    }
    saveDataPerKey(persistType, provider, data, key);
};
const getFromCache = (persistType, provider, key) => {
    var _a;
    const cache = getData$1(persistType === 'edge' ? 'local' : persistType, cacheKey);
    return (_a = cache[provider]) === null || _a === void 0 ? void 0 : _a[key];
};
const saveToCache = (persistType, provider, key, value) => {
    const cache = getData$1(persistType === 'edge' ? 'local' : persistType, cacheKey);
    if (!cache[provider]) {
        cache[provider] = { [key]: value };
    }
    else {
        cache[provider][key] = value;
    }
    saveData(persistType === 'edge' ? 'local' : persistType, cache, cacheKey);
};
const handleCaptureStorage = (provider, key, persistType, location) => {
    let data;
    try {
        switch (location) {
            case 'cookie': {
                data = getCookieValue(key);
                break;
            }
            case 'local': {
                data = localStorage.getItem(key);
                break;
            }
            case 'session': {
                data = sessionStorage.getItem(key);
            }
        }
    }
    catch {
        return;
    }
    const cachedValue = getFromCache(persistType, provider, key);
    saveToCache(persistType, provider, key, data);
    if (!data) {
        return;
    }
    if (persistType === 'edge' && cachedValue !== data) {
        saveDataToEdge(key, data, provider);
        return;
    }
    saveDataPerKey(persistType, provider, data, key);
};
const handleCapture = (provider, params) => {
    params.forEach((param) => {
        switch (param.type) {
            case 'query': {
                handleCaptureQuery(provider, param.key, param.persist);
                break;
            }
            case 'storage': {
                handleCaptureStorage(provider, param.key, param.persist, param.location);
                break;
            }
        }
    });
};

const handleGetData = (keys, callback) => {
    if (!keys || keys.length === 0) {
        error('Provide keys for get data API.');
        return;
    }
    getRequest(getGetDataURL(keys))
        .then((result) => {
        callback((result === null || result === void 0 ? void 0 : result.result) || {});
    })
        .catch(error);
};

const handleManifest = (manifest) => {
    const providerPackages = getProvidersPackage();
    const userId = handleGetUserId();
    manifest.forEach((provider) => {
        addConfiguredTag(provider.package, provider.tagName);
        addProviderVariable(provider.package, provider.variables, provider.tagName);
        if (provider.rules) {
            Object.entries(provider.rules).forEach(([name, recipe]) => {
                switch (name) {
                    case 'capture': {
                        handleCapture(provider.package, recipe);
                        return;
                    }
                }
            });
        }
        const pkg = providerPackages[provider.package];
        if (pkg && pkg.name && pkg.init) {
            pkg.init({
                userId,
                manifest: provider,
                sendTag,
                sendEdgeData: handleData,
                getEdgeData: handleGetData,
                keyName: `${keyPrefix}Store`,
            });
        }
    });
    setInitialized();
    processStubs();
};

const handleInit = (preferences) => {
    const success = setPreferences(preferences);
    if (!success) {
        return;
    }
    if (preferences.afterManifestEvents) {
        addStubs(preferences.afterManifestEvents);
    }
    const url = new URL(getInitURL());
    if (preferences.disableConsentCheck) {
        url.searchParams.set('consentDisabled', 'true');
        saveConsent({ all: true });
    }
    if (preferences.userId) {
        setUserId(preferences.userId);
        url.searchParams.set('userId', preferences.userId);
    }
    getRequest(url.href)
        .then((result) => {
        if (!result) {
            error('Initialization failed');
            return;
        }
        if (result.userId) {
            setUserId(result.userId);
        }
        const consent = getConsent();
        if (result.consent && !consent) {
            saveConsent(result.consent);
        }
        handleManifest(result.result);
    })
        .catch(error);
};

const handleUser = (key, value, providers, options) => {
    if (!key || !value) {
        error('Key or Value is missing in user API.');
        return;
    }
    saveKV({
        [key]: value,
    });
    const providerPackages = getProvidersPackage();
    const configuredTags = getConfiguredTags();
    const consent = getConsent();
    const userId = handleGetUserId();
    for (const pkg of Object.values(providerPackages)) {
        if (!pkg || !pkg.name || !pkg.user) {
            continue;
        }
        if (!configuredTags.has(pkg.name)) {
            log(`Provider ${pkg.name} is not in allow list`);
            continue;
        }
        const variables = getProviderVariables(pkg.name);
        for (const [tagName, variableSet] of Object.entries(variables)) {
            if (!isProviderInstanceAllowed(providers, pkg.name, tagName)) {
                log(`User not allowed for ${pkg.name} (${tagName})`);
                continue;
            }
            if (!hasUserConsent(consent, pkg.name, tagName)) {
                log(`User doesn't have consent for ${pkg.name} (${tagName})`);
                continue;
            }
            pkg.user({
                userId,
                data: { [key]: value },
                manifestVariables: variableSet,
            });
        }
    }
    postRequest(getUserURL(), {
        key,
        value,
        providers,
    }, options).catch(error);
};

const handleKeys = (callback) => {
    getRequest(getKeysURL())
        .then((result) => {
        callback((result === null || result === void 0 ? void 0 : result.result) || []);
    })
        .catch(error);
};

const init = (preferences) => {
    handleInit(preferences);
};
const tag = (name, data, providers, options) => {
    handleTag(name, data, providers, options);
};
const consent = (value, options) => {
    handleConsent(value, options);
};
const user = (key, value, providers, options) => {
    handleUser(key, value, providers, options);
};
const data = (value, providers, options) => {
    handleData(value, providers, options);
};
const getData = (keys, callback) => {
    handleGetData(keys, callback);
};
const keys = (callback) => {
    handleKeys(callback);
};
const getUserId = () => {
    return handleGetUserId();
};

export { consent, data, getData, getUserId, init, keys, tag, user };
